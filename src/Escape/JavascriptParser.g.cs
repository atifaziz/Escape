#region BSD 2-Clause License
//
// Copyright (C) 2014, Atif Aziz
// Copyright (C) 2013, Sebastien Ros
// Copyright (C) 2013, Thaddee Tyl <thaddee.tyl@gmail.com>
// Copyright (C) 2012, Mathias Bynens <mathias@qiwi.be>
// Copyright (C) 2012, Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
// Copyright (C) 2012, Kris Kowal <kris.kowal@cixar.com>
// Copyright (C) 2012, Yusuke Suzuki <utatane.tea@gmail.com>
// Copyright (C) 2012, Arpad Borsos <arpad.borsos@googlemail.com>
// Copyright (C) 2011, Ariya Hidayat <ariya.hidayat@gmail.com>
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
#endregion

// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// Generated: Wed, 10 Sep 2014 06:42:19 GMT

namespace Escape
{
    partial class JavaScriptParser
    {
        // The C# compiler uses a dictionary when the number of string 
        // cases in a switch statement exceeds six. The following 
        // functions are optimized set containment checks where a 
        // switch is broken into two levels to prevent the compiler 
        // from using a dictionary. In tests, this showed at least a 
        // 20% performance improvement most of the time.

        static bool InKeywordSet(string term)
        {
            if (string.IsNullOrEmpty(term)) return false;
            switch (term[0])
            {
                default: return false;
                case 'b': return term == "break";
                case 'c':
                {
                    switch (term)
                    {  
                        case "case": 
                        case "catch": 
                        case "class": 
                        case "const": 
                        case "continue": return true;
                        default: return false;
                    }
                }
                case 'd':
                {
                    switch (term)
                    {  
                        case "debugger": 
                        case "default": 
                        case "delete": 
                        case "do": return true;
                        default: return false;
                    }
                }
                case 'e':
                {
                    switch (term)
                    {  
                        case "else": 
                        case "enum": 
                        case "export": 
                        case "extends": return true;
                        default: return false;
                    }
                }
                case 'f':
                {
                    switch (term)
                    {  
                        case "finally": 
                        case "for": 
                        case "function": return true;
                        default: return false;
                    }
                }
                case 'i':
                {
                    switch (term)
                    {  
                        case "if": 
                        case "import": 
                        case "in": 
                        case "instanceof": return true;
                        default: return false;
                    }
                }
                case 'l': return term == "let";
                case 'n': return term == "new";
                case 'r': return term == "return";
                case 's':
                {
                    switch (term)
                    {  
                        case "super": 
                        case "switch": return true;
                        default: return false;
                    }
                }
                case 't':
                {
                    switch (term)
                    {  
                        case "this": 
                        case "throw": 
                        case "try": 
                        case "typeof": return true;
                        default: return false;
                    }
                }
                case 'v':
                {
                    switch (term)
                    {  
                        case "var": 
                        case "void": return true;
                        default: return false;
                    }
                }
                case 'w':
                {
                    switch (term)
                    {  
                        case "while": 
                        case "with": return true;
                        default: return false;
                    }
                }
                case 'y': return term == "yield";
            }
        }

        static bool InStrictModeReservedWordSet(string term)
        {
            if (string.IsNullOrEmpty(term)) return false;
            switch (term[0])
            {
                default: return false;
                case 'i':
                {
                    switch (term)
                    {  
                        case "implements": 
                        case "interface": return true;
                        default: return false;
                    }
                }
                case 'l': return term == "let";
                case 'p':
                {
                    switch (term)
                    {  
                        case "package": 
                        case "private": 
                        case "protected": 
                        case "public": return true;
                        default: return false;
                    }
                }
                case 's': return term == "static";
                case 'y': return term == "yield";
            }
        }

        static bool InFutureReservedWordSet(string term)
        {
            if (string.IsNullOrEmpty(term)) return false;
            switch (term[0])
            {
                default: return false;
                case 'c': return term == "class";
                case 'e':
                {
                    switch (term)
                    {  
                        case "enum": 
                        case "export": 
                        case "extends": return true;
                        default: return false;
                    }
                }
                case 'i': return term == "import";
                case 's': return term == "super";
            }
        }

    }
}